<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Functional programming with Elixir</title>

  <link rel="stylesheet" href="css/reset.css" />
  <link rel="stylesheet" href="css/reveal.css" />
  <link rel="stylesheet" href="css/theme/black.css" />

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai.css" />

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement("link");
    link.rel = "stylesheet";
    link.type = "text/css";
    link.href = window.location.search.match(/print-pdf/gi) ?
      "css/print/pdf.css" :
      "css/print/paper.css";
    document.getElementsByTagName("head")[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-background-color="#ffffff" data-background-image="img/slide-0/logo2.png"
        data-background-opacity="0.5" data-background-size="contain" data-background-position="left">
        <h1 style="text-align: right;">
          <b>functional</b>
        </h1>
        <h1 style="text-align: right;">
          <b>programming</b>
        </h1>
        <h1 style="text-align: right;">
          <b>with <font color="#4e2a8e">Elixir</font></b>
        </h1>
        <aside class="notes">
          -Predicar palabra de la programacion funcional, especifica% en Elixir.
          -No es un paradigma nuevo, decadas, pero de cuando en cuando suena fuerte.
          -Se programa de una manera declarativa, donde las funciones funcionan como una caja negra, osea sabemos lo que
          la funcion hace, no como lo hace
          -Promueve la inmutabilidad, esto significa que no cambie estado de variable
        </aside>
      </section>

      <section data-background-color="#ffffff" data-background-image="img/slide-1/bigelixir_gif-white.gif"
        data-background-opacity="0.5" data-background-size="contain">
        <h2>
          So, what's all about Elixir?
        </h2>
        <img src="img/slide-1/jose-valim.jpg" class="fragment" />
        <aside class="notes">
          - Fue creado en 2011 por Jose Valim
          - core rails dev
          - razones ( problemas en manejo de concurrencia de ruby)
          - Influencias: Erlang, ruby y Clojure
        </aside>
      </section>

      <section data-background-color="#ffffff" data-background-image="img/slide-1/bigelixir_gif-white.gif"
        data-background-opacity="0.5" data-background-size="contain" data-transition="none">
        <p data-fragment-index="9" class="fragment fade-out">
          <img src="img/slide-2/discord.png" style="width: 150px;" />
          <img src="img/slide-2/Pinterest.svg" data-fragment-index="1" class="fragment" style="width: 150px;" />
          <img src="img/slide-2/motorola.png" data-fragment-index="2" class="fragment" style="width: 150px;" />
        </p>
        <p>
          <span data-fragment-index="9" class="fragment fade-out">
            <img src="img/slide-2/heroku.png" data-fragment-index="3" class="fragment" style="width: 150px;" />

          </span>
          <img src="img/slide-2/ericsson.png" data-fragment-index="4" class="fragment" style="width: 150px;" />
          <span data-fragment-index="9" class="fragment fade-out">
            <img src="img/slide-2/cisco.png" data-fragment-index="6" class="fragment" style="width: 150px;" />
          </span>
        </p>
        <p data-fragment-index="9" class="fragment fade-out">
          <img src="img/slide-2/ibm.png" data-fragment-index="7" class="fragment" style="width: 150px;">
          <img src="img/slide-2/whatsapp.png" data-fragment-index="8" class="fragment" style="width: 150px;" />
        </p>
        <aside class="notes">
          -- Discord (voip para gamers) maneja 5m usuarios concurrentes
          -- Pinterest sstema de notificaciones (150m usuarios mensuales)
          -- Motorola Solutions elixir-erlang para desarrollo de sistemas de comuincacion

          -- Heroku Ruteo a contenedores con erlang, además de aplicaciones internas con elixir
          --Ericsson alrededor del 40% de tráfico móvil mundial funciona con soluciones de red construidas en erlang
          --RabbitMQ, Sistema de manejo de mensajería usado por miles de empresas

          -- Cisco alrededor del 90% del trafico de internet funciona a través de nodos controlados por erlang
          --IBM Cloudant funciona con erlang para sistema full-text search
          --whatsapp eralnd maneja 450 mill. ususarios
        </aside>
      </section>

      <section data-background-image="img/slide-3/ericsson-offices.jpg" data-background-opacity="0.3">
        <h2>
          So, what's all about Erlang?
        </h2>
        <p class="fragment">Concurrent</p>
        <p class="fragment">Distributed</p>
        <p class="fragment">Fault-tolerant</p>
        <p class="fragment">Hot swapping</p>
        <p class="fragment">Highly available</p>
        <aside class="notes">
          creado en 86
          para mejorar sistemas de telefonía (switches)
          Usa maquina virtual BEAM, la cual compila a C
          - Concurrente: procesos que puedan ejecutarse al mismo tiempo
          - Distribuido: también que pueda ejecutarse en distintos computadores, pudiendo compartir información entre
          ellos
          - Tolerante a fallos: Que pueda continuar funcionando después de algún error
          - Que se pueda cambiar en caliente, o mientras funciona, sin que esto signifique una caida del sistema.
          - Y que esto eventualmente se traduce en construir sistemas confiables con un alto rendimiento operacional.
        </aside>
      </section>

      <section data-background-image="img/slide-3/ericsson-offices.jpg" data-background-opacity="0.5"
        data-transition="none" data-background-color="#ffffff">
        <img src="img/slide-4/step-1.png" />
        <aside class="notes">
          Para ejemplificar, ellos querían construir switches telefónicos, donde 2 personas se comunicasen al mismo
          tiempo.
        </aside>
      </section>
      <section data-background-image="img/slide-3/ericsson-offices.jpg" data-background-opacity="0.5"
        data-transition="none" data-background-color="#ffffff">
        <img src="img/slide-4/step-2.png" />
      </section>
      <section data-background-image="img/slide-3/ericsson-offices.jpg" data-background-opacity="0.5"
        data-transition="none" data-background-color="#ffffff">
        <img src="img/slide-4/step-3.png" />
        <aside class="notes">
          Pero que además pudiese manejar varias conexiones al mismo tiempo, o varias personas hablando a la vez. Aquí
          entra el concepto de concurrencia de multiples personas comunicandose al mismo tiempo.
        </aside>
      </section>
      <section data-background-image="img/slide-3/ericsson-offices.jpg" data-background-opacity="0.5"
        data-transition="none" data-background-color="#ffffff">
        <img src="img/slide-4/step-4.png" />
        <aside class="notes">
          También nace el concepto de distribución, donde switches se comunican entre ellos, por ejemplo alguien que
          quiera llamar a una persona que esté en otra ciudad y tengan que intercambiar información entre switches para
          saber si la persona está disponible o no.
          En caso que quisieran actualizar la información de estos switches, eso no debería suponer un corte de las
          llamadas, las personas deberían poder ser capaces de seguir hablando.
        </aside>
      </section>
      <section data-background-image="img/slide-3/ericsson-offices.jpg" data-background-opacity="0.5"
        data-transition="fade" data-background-color="#ffffff">
        <img src="img/slide-4/step-5.png" />
        <aside class="notes">
          Esto en el fondo es el mismo escenario que vemos actualmente en sistemas web, donde varias personas se
          comunican.
        </aside>
      </section>

      <section data-background-color="#ffffff" data-background-image="img/slide-1/bigelixir_gif-white.gif"
        data-background-opacity="0.5" data-background-size="contain">
        <h2>
          Then, why Elixir?
        </h2>
        <p class="fragment">New generations</p>
        <p class="fragment">Done for web</p>
        <p class="fragment">Ruby-like</p>
        <p class="fragment">Extensibility</p>
        <p class="fragment">Tooling</p>
        <p class="fragment">Compiled to BEAM</p>
        <p class="fragment">Erlang-powered</p>
        <aside class="notes">
          1)Elixir es Erlang para nuevas generaciones.
          Se podría decir que erlang como lenguaje no fue diseñado como un lenguaje de propósito general como java, js,
          C#, etc, donde de alguna forma su sintaxis fue desarrollandose para ser similar entre lenguajes populares
          entre desarrolladores. Erlang se encuentra basado en lenguajes como prolog o smalltalk, (lenguajes de años 70)
          de los cuales su sintaxis no es muy amigable.
          2)En erlang se pueden desarrollar aplicaciones web, pero de alguna forma han fracasado en popularizarlo,
          elixiri fue construido con eso en mente
          3)Elixir está basado en ruby, aspectos de sintaxis.
          4)El lenguaje se peude extender de acuerdo a nuestras necesidades, pudiendo hacer metaprogramacion o crear DSL
          5)Herramientas disponibles para facilitar desarrollo, como mix para crear proyectos, ejecutar tareas, correr
          tests.
          Integra con Hex, para manejo de paquetes
          iex shell interactivo
          6)Todo es compilado al mismo bytecode que interpreta BEAM.
          7)No solo el lenguaje funciona con erlang como base, sino que además se peude acceder a todas las librerias
          disponibes en erlang
        </aside>
      </section>

      <section data-background-color="#ffffff">
        <h3>
          Talk is cheap
        </h3>
        <img src="img/tenor.gif" />
        <h3>
          Show me the code
        </h3>
        <aside class="notes">
          Suficiente palabreria, a mostrar algo de codigo
          Una repasada sobre los aspectos mas importantes del lenguaje o los que causan mas complicacion.

        </aside>
      </section>

      <section data-transition="none" data-background-image="img/slide-6/3922970674_eed753c003_b.jpg"
        data-background-opacity="0.5">
        <h2>
          Immutability
        </h2>
        <pre class="fragment"><code class="ruby" data-trim data-line-numbers>
my_mutable_values = [10]

class MyClass
  def self.please_dont_modify_this(values)
    # Do stuff
    values.push(rand(10))
    # Do more stuff
  end
end

MyClass.please_dont_modify_this(my_mutable_values)
my_mutable_values # => [10, ???]
        </code></pre>
        <aside class="notes">
          Elixir fuerza que los datos no puedan ser alterados una vez creados.
          Como ejemplo este codigo en ruby
          Piensa en este codigo corriendo concurrentemente (en procesos o threads) , nunca se podría saber de que forma
          se
          ejecutaria si todos lo modifican a la vez
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/slide-6/3922970674_eed753c003_b.jpg"
        data-background-opacity="0.5">
        <h2>
          Immutability
        </h2>
        <pre><code class="elixir" data-trim data-line-numbers>
my_immutable_values = [10]

defmodule MyModule do
  def please_dont_modify_this(values) do
    # Do stuff
    values = [ :rand.uniform(10) | values]
    # Do more stuff
  end
end

MyModule.please_dont_modify_this(my_immutable_values)
my_immutable_values # => [10]
        </code></pre>
        <aside class="notes">
          -En caso contrario en elixir todos los datos son inmutables. Poniendo el mismo supuesto del código corriendo
          concurrentemente, en caso de que la variable sea modificada, elixir realizará una copia del original donde da
          lo mismo los cambios que se realicen dentro de la funcion, la variable origianl no cambia de valor.
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/slide-6/3922970674_eed753c003_b.jpg"
        data-background-opacity="0.5">
        <h2>
          Immutability
        </h2>
        <pre><code class="elixir" data-trim data-line-numbers="1">
my_immutable_values = [10, 20, 30, 40, 50]

defmodule MyModule do
  def please_dont_modify_this(values) do
    # Do stuff
    other_values = [ :rand.uniform(10) | values]
    # Do more stuff
  end
end

MyModule.please_dont_modify_this(my_immutable_values)
my_immutable_values # => [10]
        </code></pre>
        <aside class="notes">
          -Implicancias en rendimiento, podria verse como ineficiente, pero no lo es.
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/slide-6/3922970674_eed753c003_b.jpg"
        data-background-opacity="0.5">
        <h2>
          Immutability
        </h2>
        <pre><code class="elixir" data-trim data-line-numbers="4,6,7">
my_immutable_values = [10, 20, 30, 40, 50]

defmodule MyModule do
  def please_dont_modify_this(values) do
    # Do stuff
    # Uses random value as head and `values` as tail
    other_values = [ :rand.uniform(10) | values]
    # Do more stuff
  end
end

MyModule.please_dont_modify_this(my_immutable_values)
my_immutable_values # => [10]
        </code></pre>
        <aside class="notes">
          Elixir sabe que los datos son
          inmutables, por lo que puede reusarlos en parte para construir nuevas estructuras.
          La mayoria de lenguajes crearian una nueva lista conteniendo los valores de la original.
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre class="fragment"><code class="elixir" data-line-numbers>iex(1)> a = "hola"
"hola"




        </code></pre>
        <aside class="notes">
          Cuando un programador ve esto podría decir que a una variable "a" se le está asignando el valor "hola", pero
          en elixir el simbolo = es un operador de matching, que es mas bien una afirmación de que tanto el valor de la
          izquierda como de la derecha son iguales y elixir busca que estos valores coincidan.
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="3,4">iex(1)> a = "hola"
"hola"
iex(2)> "hola" = a
"hola"


        </code></pre>
        <aside class="notes">
          Por ejemplo en este caso la variable "a" ya tiene asignado el valor "hola", entonces el matching fue existoso,
          ya que ambos lados de la aserción son iguales.
          Bastante similar a lo que seria una ecuación matemática.
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="5,6">iex(1)> a = "hola"
"hola"
iex(2)> "hola" = a
"hola"
iex(3)> "hello" = a
** (MatchError) no match of right hand side value: "hola"
        </code></pre>
        <aside class="notes">
          En el último caso simplemente falla, ya que "hello" no es igual a "hola".
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="1-4">iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [a, b, c] = list
[1, 2, 3]






</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="5-10">iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [a, b, c] = list
[1, 2, 3]
iex(3)> a
1
iex(4)> b
2
iex(5)> c
3
</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="1-4">iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [1, will_match, 3] = list
[1, 2, 3]




</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="5-6">iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [1, will_match, 3] = list
[1, 2, 3]
iex(3)> [wont_match, 2, 4] = list
** (MatchError) no match of right hand side value: [1,2,3]


</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/0575-ShapeSortingCube-3PcsOut_1024x1024.png"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pattern Matching (<b>
            <font color="#4e2a8e">=</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers="7-8">iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [1, will_match, 3] = list
[1, 2, 3]
iex(3)> [maybe_match, 2, 4] = list
** (MatchError) no match of right hand side value: [1,2,3]
iex(3)> [maybe_match, 2, _] = list
[1, 2, 3]
</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre class="fragment"><code class="elixir" data-line-numbers>defmodule Calc do
  def add(x, y), do: x + y
end
Calc.add(2,3) # 5
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="4-10,12">defmodule Calc do
  def add(x, y), do: x + y

  def sum(n) do
    if(1 == n) do
      1
    else
      n + sum(n-1)
    end
  end
end
Calc.sum(5) # 15
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="4,5,7">defmodule Calc do
  def add(x, y), do: x + y

  def sum(1), do: 1
  def sum(n), do: n + sum(n-1)
end
Calc.sum(5) # 15
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="4,5,7">defmodule Calc do
  def add(x, y), do: x + y

  def sum(1), do: 1
  def sum(n), do: n + sum(n-1)
end
Calc.sum(-1) # looping forever
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="4-10,12">defmodule Calc do
  def add(x, y), do: x + y

  def sum(n) do
    if(n == 1) do
      1
    else
      if(n > 1) do
        n + sum(n-1)
      end
    end
  end
end
Calc.sum(-1) # nil
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="4,5,7">defmodule Calc do
  def add(x, y), do: x + y

  def sum(1), do: 1
  def sum(n) when n > 0, do: n + sum(n-1)
end
Calc.sum(-1) # no function clause matching in Calc.sum/1
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="7">defmodule Calc do
  def add(x, y), do: x + y

  def sum(1), do: 1
  def sum(n) when n > 0, do: n + sum(n-1)
end
Calc.sum([3, 5, 7]) # no function clause matching in Calc.sum/1
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/giphy-facebook_s.jpg" data-background-opacity="0.5">
        <h2>
          Functions
        </h2>
        <pre><code class="elixir" data-line-numbers="5-7,9,10">defmodule Calc do
  def add(x, y), do: x + y

  def sum(1), do: 1
  def sum(n) when is_integer(n) and n > 0, do: n + sum(n-1)
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum(7) # 28
Calc.sum([3, 5, 7]) # 15
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <h4 class="fragment">[ head | tail ]</h4>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir">[] # []



</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir">[] # []
[3] # [3 | []]


</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir">[] # []
[3] # [3 | []]
[3, 2] # [3 | [2 | []]]

</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir">[] # []
[3] # [3 | []]
[3, 2] # [3 | [2 | []]]
[3, 2, 1] # [3 | [2 | [1 | []]]]
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir" data-line-numbers="3,5">defmodule Calc do
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum([3, 5, 7])





</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir" data-line-numbers="3,6">defmodule Calc do
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum([3, 5, 7])
# 3 + sum([5 | 7])




</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir" data-line-numbers="3,7">defmodule Calc do
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum([3, 5, 7])
# 3 + sum([5 | 7])
# 3 + 5 + sum([7])



</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir" data-line-numbers="3,8">defmodule Calc do
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum([3, 5, 7])
# 3 + sum([5 | 7])
# 3 + 5 + sum([7])
# 3 + 5 + 7 + sum([])


</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir" data-line-numbers="2,9">defmodule Calc do
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum([3, 5, 7])
# 3 + sum([5 | 7])
# 3 + 5 + sum([7])
# 3 + 5 + 7 + sum([])
# 3 + 5 + 7 + 0

</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/fractal-1-fine.jpg" data-background-opacity="0.5">
        <h2>
          Lists and Recursion
        </h2>
        <pre><code class="elixir" data-line-numbers="5">defmodule Calc do
  def sum([]), do: 0
  def sum([ head | tail]), do: head + sum(tail)
end
Calc.sum([3, 5, 7]) # 15
# 3 + sum([5 | 7])
# 3 + 5 + sum([7])
# 3 + 5 + 7 + sum([])
# 3 + 5 + 7 + 0

</code></pre>
      </section>

      <section data-background-image="img/source.gif" data-background-opacity="0.5">
        <h2>
          Give me moar elixir
        </h2>
        <aside class="notes">
          - structs
          - let it crash, concepto de procesos, supervisores,
          - Open Telecom Platform
          - Agents, Genserver
          - Phoenix
        </aside>
        <p>
          <a class="fragment" href="https://elixirschool.com">
            elixirschool.com
          </a>
        </p>
        <p>
          <a class="fragment" href="https://www.youtube.com/watch?list=PLaY7qWIrmqtFoZLvOvYRZG5hl367UybRp&v=Jydr6UUYs2U">
            Zero to Hero in Elixir
          </a>
        </p>
        <p>
          <a class="fragment" href="https://github.com/h4cc/awesome-elixir">
            github.com/h4cc/awesome-elixir
          </a>
        </p>

      </section>

      <section data-background-image="img/30167768_10156292374609441_5736661175655595489_o.jpg"
        data-background-opacity="0.5">
        <h2>
          Questions?
        </h2>
        <a href="http://alagos.github.io/elixir-talk">
          alagos.github.io/elixir-talk
        </a>
      </section>

      <section data-transition="none" data-background-image="img/e3_2019_warp_pipe_pass_0.jpg"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pipes (<b>
            <font color="#4e2a8e">|&gt;</font>
          </b>)
        </h2>
        <pre class="fragment"><code class="elixir" data-line-numbers>store = Store.find_nearest
games = Game.best_selling_for(store)
customers = Customer.find_by_games(games)
invoices = Calc.generate_invoices(customers, 2019)
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/e3_2019_warp_pipe_pass_0.jpg"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pipes (<b>
            <font color="#4e2a8e">|&gt;</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers>invoices = Calc.generate_invoices(
  Customer.find_by_games(
    Game.best_selling_for(Store.find_nearest)
  ), 2019
)
</code></pre>
      </section>

      <section data-transition="none" data-background-image="img/e3_2019_warp_pipe_pass_0.jpg"
        data-background-opacity="0.5" data-background-color="#ffffff">
        <h2>
          Pipes (<b>
            <font color="#4e2a8e">|&gt;</font>
          </b>)
        </h2>
        <pre><code class="elixir" data-line-numbers>invoices = Store.find_nearest
  |> Game.best_selling_for
  |> Customer.find_by_games
  |> Calc.generate_invoices(2019)
</code></pre>
      </section>
    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // Add the current slide number to the URL hash so that reloading the
      // page/copying the URL will return you to the same slide
      hash: true,

      // Push each slide change to the browser history. Implies `hash: true`
      history: true,
      dependencies: [{
          src: "plugin/markdown/marked.js"
        },
        {
          src: "plugin/markdown/markdown.js"
        },
        {
          src: "plugin/notes/notes.js",
          async: true
        },
        {
          src: "plugin/highlight/highlight.js",
          async: true
        }
      ]
    });
  </script>
</body>

</html>
